{"version":3,"file":"dist/830.QWC2App.js","mappings":"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","sources":["webpack://qwc2-demo-app/./node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-conversion-utils.js","webpack://qwc2-demo-app/./node_modules/@loaders.gl/core/dist/lib/utils/response-utils.js","webpack://qwc2-demo-app/./node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js","webpack://qwc2-demo-app/./node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js","webpack://qwc2-demo-app/./node_modules/@loaders.gl/core/dist/lib/utils/mime-type-utils.js","webpack://qwc2-demo-app/./node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js","webpack://qwc2-demo-app/./node_modules/@loaders.gl/core/dist/lib/fetch/fetch-error.js","webpack://qwc2-demo-app/./node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js","webpack://qwc2-demo-app/./node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/file-aliases.js","webpack://qwc2-demo-app/./node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js","webpack://qwc2-demo-app/./node_modules/@loaders.gl/loader-utils/dist/lib/iterators/async-iteration.js","webpack://qwc2-demo-app/./node_modules/@loaders.gl/loader-utils/dist/lib/module-utils/js-module-utils.js","webpack://qwc2-demo-app/./node_modules/@loaders.gl/loader-utils/dist/lib/files/node-file-facade.js","webpack://qwc2-demo-app/./node_modules/@loaders.gl/core/dist/lib/fetch/fetch-file.js","webpack://qwc2-demo-app/./node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport * as node from \"../node/buffer.js\";\n/**\n * Check for Node.js `Buffer` (without triggering bundler to include Buffer polyfill on browser)\n */\nexport function isBuffer(value) {\n    return value && typeof value === 'object' && value.isBuffer;\n}\n/**\n * Converts to Node.js `Buffer` (without triggering bundler to include Buffer polyfill on browser)\n * @todo better data type\n */\nexport function toBuffer(data) {\n    return node.toBuffer ? node.toBuffer(data) : data;\n}\n/**\n * Convert an object to an array buffer\n */\nexport function toArrayBuffer(data) {\n    // Note: Should be called first, Buffers can trigger other detections below\n    if (isBuffer(data)) {\n        return node.toArrayBuffer(data);\n    }\n    if (data instanceof ArrayBuffer) {\n        return data;\n    }\n    // Careful - Node Buffers look like Uint8Arrays (keep after isBuffer)\n    if (ArrayBuffer.isView(data)) {\n        if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {\n            return data.buffer;\n        }\n        return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n    }\n    if (typeof data === 'string') {\n        const text = data;\n        const uint8Array = new TextEncoder().encode(text);\n        return uint8Array.buffer;\n    }\n    // HACK to support Blob polyfill\n    if (data && typeof data === 'object' && data._toArrayBuffer) {\n        return data._toArrayBuffer();\n    }\n    throw new Error('toArrayBuffer');\n}\n","// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isResponse } from \"../../javascript-utils/is-type.js\";\nimport { FetchError } from \"../fetch/fetch-error.js\";\nimport { getResourceContentLength, getResourceUrl, getResourceMIMEType } from \"./resource-utils.js\";\nimport { shortenUrlForDisplay } from \"./url-utils.js\";\n/**\n * Returns a Response object\n * Adds content-length header when possible\n *\n * @param resource\n */\nexport async function makeResponse(resource) {\n    if (isResponse(resource)) {\n        return resource;\n    }\n    // Add content-length header if possible\n    const headers = {};\n    const contentLength = getResourceContentLength(resource);\n    if (contentLength >= 0) {\n        headers['content-length'] = String(contentLength);\n    }\n    // `new Response(File)` does not preserve content-type and URL\n    // so we add them here\n    const url = getResourceUrl(resource);\n    const type = getResourceMIMEType(resource);\n    if (type) {\n        headers['content-type'] = type;\n    }\n    // Add a custom header with initial bytes if available\n    const initialDataUrl = await getInitialDataUrl(resource);\n    if (initialDataUrl) {\n        headers['x-first-bytes'] = initialDataUrl;\n    }\n    // TODO - is this the best way of handling strings?\n    // Maybe package as data URL instead?\n    if (typeof resource === 'string') {\n        // Convert to ArrayBuffer to avoid Response treating it as a URL\n        resource = new TextEncoder().encode(resource);\n    }\n    // Attempt to create a Response from the resource, adding headers and setting url\n    const response = new Response(resource, { headers });\n    // We can't control `Response.url` via constructor, use a property override to record URL.\n    Object.defineProperty(response, 'url', { value: url });\n    return response;\n}\n/**\n * Checks response status (async) and throws a helpful error message if status is not OK.\n * @param response\n */\nexport async function checkResponse(response) {\n    if (!response.ok) {\n        const error = await getResponseError(response);\n        throw error;\n    }\n}\n/**\n * Checks response status (sync) and throws a helpful error message if status is not OK.\n * @param response\n */\nexport function checkResponseSync(response) {\n    if (!response.ok) {\n        let message = `${response.status} ${response.statusText}`;\n        message = message.length > 60 ? `${message.slice(0, 60)}...` : message;\n        throw new Error(message);\n    }\n}\n// HELPERS\nasync function getResponseError(response) {\n    const shortUrl = shortenUrlForDisplay(response.url);\n    let message = `Failed to fetch resource (${response.status}) ${response.statusText}: ${shortUrl}`;\n    message = message.length > 100 ? `${message.slice(0, 100)}...` : message;\n    const info = {\n        reason: response.statusText,\n        url: response.url,\n        response\n    };\n    // See if we got an error message in the body\n    try {\n        const contentType = response.headers.get('Content-Type');\n        info.reason =\n            !response.bodyUsed && contentType?.includes('application/json')\n                ? await response.json()\n                : await response.text();\n    }\n    catch (error) {\n        // eslint forbids return in a finally statement, so we just catch here\n    }\n    return new FetchError(message, info);\n}\nasync function getInitialDataUrl(resource) {\n    const INITIAL_DATA_LENGTH = 5;\n    if (typeof resource === 'string') {\n        return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;\n    }\n    if (resource instanceof Blob) {\n        const blobSlice = resource.slice(0, 5);\n        return await new Promise((resolve) => {\n            const reader = new FileReader();\n            reader.onload = (event) => resolve(event?.target?.result);\n            reader.readAsDataURL(blobSlice);\n        });\n    }\n    if (resource instanceof ArrayBuffer) {\n        const slice = resource.slice(0, INITIAL_DATA_LENGTH);\n        const base64 = arrayBufferToBase64(slice);\n        return `data:base64,${base64}`;\n    }\n    return null;\n}\n// https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string\nfunction arrayBufferToBase64(buffer) {\n    let binary = '';\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < bytes.byteLength; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n}\n","// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst QUERY_STRING_PATTERN = /\\?.*/;\nexport function extractQueryString(url) {\n    const matches = url.match(QUERY_STRING_PATTERN);\n    return matches && matches[0];\n}\nexport function stripQueryString(url) {\n    return url.replace(QUERY_STRING_PATTERN, '');\n}\nexport function shortenUrlForDisplay(url) {\n    if (url.length < 50) {\n        return url;\n    }\n    const urlEnd = url.slice(url.length - 15);\n    const urlStart = url.substr(0, 32);\n    return `${urlStart}...${urlEnd}`;\n}\n","/**\n * compare two binary arrays for equality\n * @param a\n * @param b\n * @param byteLength\n */\nexport function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {\n    byteLength = byteLength || arrayBuffer1.byteLength;\n    if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n        return false;\n    }\n    const array1 = new Uint8Array(arrayBuffer1);\n    const array2 = new Uint8Array(arrayBuffer2);\n    for (let i = 0; i < array1.length; ++i) {\n        if (array1[i] !== array2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Concatenate a sequence of ArrayBuffers from arguments\n * @return A concatenated ArrayBuffer\n */\nexport function concatenateArrayBuffers(...sources) {\n    return concatenateArrayBuffersFromArray(sources);\n}\n/**\n * Concatenate a sequence of ArrayBuffers from array\n * @return A concatenated ArrayBuffer\n */\nexport function concatenateArrayBuffersFromArray(sources) {\n    // Make sure all inputs are wrapped in typed arrays\n    const sourceArrays = sources.map((source2) => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);\n    // Get length of all inputs\n    const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);\n    // Allocate array with space for all inputs\n    const result = new Uint8Array(byteLength);\n    // Copy the subarrays\n    let offset = 0;\n    for (const sourceArray of sourceArrays) {\n        result.set(sourceArray, offset);\n        offset += sourceArray.byteLength;\n    }\n    // We work with ArrayBuffers, discard the typed array wrapper\n    return result.buffer;\n}\n/**\n * Concatenate arbitrary count of typed arrays\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays\n * @param - list of arrays. All arrays should be the same type\n * @return A concatenated TypedArray\n */\nexport function concatenateTypedArrays(...typedArrays) {\n    // @ts-ignore\n    const arrays = typedArrays;\n    // @ts-ignore\n    const TypedArrayConstructor = (arrays && arrays.length > 1 && arrays[0].constructor) || null;\n    if (!TypedArrayConstructor) {\n        throw new Error('\"concatenateTypedArrays\" - incorrect quantity of arguments or arguments have incompatible data types');\n    }\n    const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);\n    // @ts-ignore typescript does not like dynamic constructors\n    const result = new TypedArrayConstructor(sumLength);\n    let offset = 0;\n    for (const array of arrays) {\n        result.set(array, offset);\n        offset += array.length;\n    }\n    return result;\n}\n/**\n * Copy a view of an ArrayBuffer into new ArrayBuffer with byteOffset = 0\n * @param arrayBuffer\n * @param byteOffset\n * @param byteLength\n */\nexport function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n    const subArray = byteLength !== undefined\n        ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength)\n        : new Uint8Array(arrayBuffer).subarray(byteOffset);\n    const arrayCopy = new Uint8Array(subArray);\n    return arrayCopy.buffer;\n}\n","// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// TODO - build/integrate proper MIME type parsing\n// https://mimesniff.spec.whatwg.org/\nconst DATA_URL_PATTERN = /^data:([-\\w.]+\\/[-\\w.+]+)(;|,)/;\nconst MIME_TYPE_PATTERN = /^([-\\w.]+\\/[-\\w.+]+)/;\n/**\n * Compare two MIME types, case insensitively etc.\n * @param mimeType1\n * @param mimeType2\n * @returns true if the MIME types are equivalent\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#structure_of_a_mime_type\n */\nexport function compareMIMETypes(mimeType1, mimeType2) {\n    if (mimeType1.toLowerCase() === mimeType2.toLowerCase()) {\n        return true;\n    }\n    return false;\n}\n/**\n * Remove extra data like `charset` from MIME types\n * @param mimeString\n * @returns A clean MIME type, or an empty string\n *\n * @todo - handle more advanced MIMETYpes, multiple types\n * @todo - extract charset etc\n */\nexport function parseMIMEType(mimeString) {\n    // If resource is a data url, extract any embedded mime type\n    const matches = MIME_TYPE_PATTERN.exec(mimeString);\n    if (matches) {\n        return matches[1];\n    }\n    return mimeString;\n}\n/**\n * Extract MIME type from data URL\n *\n * @param mimeString\n * @returns A clean MIME type, or an empty string\n *\n * @todo - handle more advanced MIMETYpes, multiple types\n * @todo - extract charset etc\n */\nexport function parseMIMETypeFromURL(url) {\n    // If resource is a data URL, extract any embedded mime type\n    const matches = DATA_URL_PATTERN.exec(url);\n    if (matches) {\n        return matches[1];\n    }\n    return '';\n}\n","// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isResponse, isBlob } from \"../../javascript-utils/is-type.js\";\nimport { parseMIMEType, parseMIMETypeFromURL } from \"./mime-type-utils.js\";\nimport { stripQueryString } from \"./url-utils.js\";\n/**\n * Returns the URL associated with this resource.\n * The returned value may include a query string and need further processing.\n * If it cannot determine url, the corresponding value will be an empty string\n *\n * @todo string parameters are assumed to be URLs\n */\nexport function getResourceUrl(resource) {\n    // If resource is a `Response`, it contains the information directly as a field\n    if (isResponse(resource)) {\n        const response = resource;\n        return response.url;\n    }\n    // If the resource is a Blob or a File (subclass of Blob)\n    if (isBlob(resource)) {\n        const blob = resource;\n        // File objects have a \"name\" property. Blob objects don't have any\n        // url (name) information\n        return blob.name || '';\n    }\n    if (typeof resource === 'string') {\n        return resource;\n    }\n    // Unknown\n    return '';\n}\n/**\n * Returns the URL associated with this resource.\n * The returned value may include a query string and need further processing.\n * If it cannot determine url, the corresponding value will be an empty string\n *\n * @todo string parameters are assumed to be URLs\n */\nexport function getResourceMIMEType(resource) {\n    // If resource is a response, it contains the information directly\n    if (isResponse(resource)) {\n        const response = resource;\n        const contentTypeHeader = response.headers.get('content-type') || '';\n        const noQueryUrl = stripQueryString(response.url);\n        return parseMIMEType(contentTypeHeader) || parseMIMETypeFromURL(noQueryUrl);\n    }\n    // If the resource is a Blob or a File (subclass of Blob)\n    if (isBlob(resource)) {\n        const blob = resource;\n        return blob.type || '';\n    }\n    if (typeof resource === 'string') {\n        return parseMIMETypeFromURL(resource);\n    }\n    // Unknown\n    return '';\n}\n/**\n  * Returns (approximate) content length for a resource if it can be determined.\n  * Returns -1 if content length cannot be determined.\n  * @param resource\n\n  * @note string parameters are NOT assumed to be URLs\n  */\nexport function getResourceContentLength(resource) {\n    if (isResponse(resource)) {\n        const response = resource;\n        return response.headers['content-length'] || -1;\n    }\n    if (isBlob(resource)) {\n        const blob = resource;\n        return blob.size;\n    }\n    if (typeof resource === 'string') {\n        // TODO - handle data URL?\n        return resource.length;\n    }\n    if (resource instanceof ArrayBuffer) {\n        return resource.byteLength;\n    }\n    if (ArrayBuffer.isView(resource)) {\n        return resource.byteLength;\n    }\n    return -1;\n}\n","// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport class FetchError extends Error {\n    constructor(message, info) {\n        super(message);\n        this.reason = info.reason;\n        this.url = info.url;\n        this.response = info.response;\n    }\n    /** A best effort reason for why the fetch failed */\n    reason;\n    /** The URL that failed to load. Empty string if not available. */\n    url;\n    /** The Response object, if any. */\n    response;\n}\n","// Beginning of a minimal implementation of the Node.js path API, that doesn't pull in big polyfills.\nimport { getCWD } from \"./get-cwd.js\";\n/**\n * Replacement for Node.js path.filename\n * @param url\n */\nexport function filename(url) {\n    const slashIndex = url ? url.lastIndexOf('/') : -1;\n    return slashIndex >= 0 ? url.substr(slashIndex + 1) : '';\n}\n/**\n * Replacement for Node.js path.dirname\n * @param url\n */\nexport function dirname(url) {\n    const slashIndex = url ? url.lastIndexOf('/') : -1;\n    return slashIndex >= 0 ? url.substr(0, slashIndex) : '';\n}\n/**\n * Replacement for Node.js path.join\n * @param parts\n */\nexport function join(...parts) {\n    const separator = '/';\n    parts = parts.map((part, index) => {\n        if (index) {\n            part = part.replace(new RegExp(`^${separator}`), '');\n        }\n        if (index !== parts.length - 1) {\n            part = part.replace(new RegExp(`${separator}$`), '');\n        }\n        return part;\n    });\n    return parts.join(separator);\n}\n/* eslint-disable no-continue */\n/**\n * https://nodejs.org/api/path.html#path_path_resolve_paths\n * @param paths A sequence of paths or path segments.\n * @return resolved path\n * Forked from BTOdell/path-resolve under MIT license\n * @see https://github.com/BTOdell/path-resolve/blob/master/LICENSE\n */\nexport function resolve(...components) {\n    const paths = [];\n    for (let _i = 0; _i < components.length; _i++) {\n        paths[_i] = components[_i];\n    }\n    let resolvedPath = '';\n    let resolvedAbsolute = false;\n    let cwd;\n    for (let i = paths.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n        let path;\n        if (i >= 0) {\n            path = paths[i];\n        }\n        else {\n            if (cwd === undefined) {\n                cwd = getCWD();\n            }\n            path = cwd;\n        }\n        // Skip empty entries\n        if (path.length === 0) {\n            continue;\n        }\n        resolvedPath = `${path}/${resolvedPath}`;\n        resolvedAbsolute = path.charCodeAt(0) === SLASH;\n    }\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n    // Normalize the path (removes leading slash)\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n    if (resolvedAbsolute) {\n        return `/${resolvedPath}`;\n    }\n    else if (resolvedPath.length > 0) {\n        return resolvedPath;\n    }\n    return '.';\n}\nconst SLASH = 47;\nconst DOT = 46;\n/**\n * Resolves . and .. elements in a path with directory names\n * Forked from BTOdell/path-resolve under MIT license\n * @see https://github.com/BTOdell/path-resolve/blob/master/LICENSE\n */\n/* eslint-disable max-depth */\n// eslint-disable-next-line complexity, max-statements\nfunction normalizeStringPosix(path, allowAboveRoot) {\n    let res = '';\n    let lastSlash = -1;\n    let dots = 0;\n    let code;\n    let isAboveRoot = false;\n    for (let i = 0; i <= path.length; ++i) {\n        if (i < path.length) {\n            code = path.charCodeAt(i);\n        }\n        else if (code === SLASH) {\n            break;\n        }\n        else {\n            code = SLASH;\n        }\n        if (code === SLASH) {\n            if (lastSlash === i - 1 || dots === 1) {\n                // NOOP\n            }\n            else if (lastSlash !== i - 1 && dots === 2) {\n                if (res.length < 2 ||\n                    !isAboveRoot ||\n                    res.charCodeAt(res.length - 1) !== DOT ||\n                    res.charCodeAt(res.length - 2) !== DOT) {\n                    if (res.length > 2) {\n                        const start = res.length - 1;\n                        let j = start;\n                        for (; j >= 0; --j) {\n                            if (res.charCodeAt(j) === SLASH) {\n                                break;\n                            }\n                        }\n                        if (j !== start) {\n                            res = j === -1 ? '' : res.slice(0, j);\n                            lastSlash = i;\n                            dots = 0;\n                            isAboveRoot = false;\n                            continue;\n                        }\n                    }\n                    else if (res.length === 2 || res.length === 1) {\n                        res = '';\n                        lastSlash = i;\n                        dots = 0;\n                        isAboveRoot = false;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot) {\n                    if (res.length > 0) {\n                        res += '/..';\n                    }\n                    else {\n                        res = '..';\n                    }\n                    isAboveRoot = true;\n                }\n            }\n            else {\n                const slice = path.slice(lastSlash + 1, i);\n                if (res.length > 0) {\n                    res += `/${slice}`;\n                }\n                else {\n                    res = slice;\n                }\n                isAboveRoot = false;\n            }\n            lastSlash = i;\n            dots = 0;\n        }\n        else if (code === DOT && dots !== -1) {\n            ++dots;\n        }\n        else {\n            dots = -1;\n        }\n    }\n    return res;\n}\n","// Simple file alias mechanisms for tests.\nlet pathPrefix = '';\nconst fileAliases = {};\n/*\n * Set a relative path prefix\n */\nexport function setPathPrefix(prefix) {\n    pathPrefix = prefix;\n}\n/*\n * Get the relative path prefix\n */\nexport function getPathPrefix() {\n    return pathPrefix;\n}\n/**\n *\n * @param aliases\n *\n * Note: addAliases are an experimental export, they are only for testing of loaders.gl loaders\n * not intended as a generic aliasing mechanism\n */\nexport function addAliases(aliases) {\n    Object.assign(fileAliases, aliases);\n}\n/**\n * Resolves aliases and adds path-prefix to paths\n */\nexport function resolvePath(filename) {\n    for (const alias in fileAliases) {\n        if (filename.startsWith(alias)) {\n            const replacement = fileAliases[alias];\n            filename = filename.replace(alias, replacement);\n        }\n    }\n    if (!filename.startsWith('http://') && !filename.startsWith('https://')) {\n        filename = `${pathPrefix}${filename}`;\n    }\n    return filename;\n}\n","// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst isBoolean = (x) => typeof x === 'boolean';\nconst isFunction = (x) => typeof x === 'function';\nexport const isObject = (x) => x !== null && typeof x === 'object';\nexport const isPureObject = (x) => isObject(x) && x.constructor === {}.constructor;\nexport const isPromise = (x) => isObject(x) && isFunction(x.then);\nexport const isIterable = (x) => Boolean(x) && typeof x[Symbol.iterator] === 'function';\nexport const isAsyncIterable = (x) => x && typeof x[Symbol.asyncIterator] === 'function';\nexport const isIterator = (x) => x && isFunction(x.next);\nexport const isResponse = (x) => (typeof Response !== 'undefined' && x instanceof Response) ||\n    (x && x.arrayBuffer && x.text && x.json);\nexport const isFile = (x) => typeof File !== 'undefined' && x instanceof File;\nexport const isBlob = (x) => typeof Blob !== 'undefined' && x instanceof Blob;\n/** Check for Node.js `Buffer` without triggering bundler to include buffer polyfill */\nexport const isBuffer = (x) => x && typeof x === 'object' && x.isBuffer;\nexport const isWritableDOMStream = (x) => isObject(x) && isFunction(x.abort) && isFunction(x.getWriter);\nexport const isReadableDOMStream = (x) => (typeof ReadableStream !== 'undefined' && x instanceof ReadableStream) ||\n    (isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.getReader));\n// Not implemented in Firefox: && isFunction(x.pipeTo)\nexport const isWritableNodeStream = (x) => isObject(x) && isFunction(x.end) && isFunction(x.write) && isBoolean(x.writable);\nexport const isReadableNodeStream = (x) => isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);\nexport const isReadableStream = (x) => isReadableDOMStream(x) || isReadableNodeStream(x);\nexport const isWritableStream = (x) => isWritableDOMStream(x) || isWritableNodeStream(x);\n","import { concatenateArrayBuffers } from \"../binary-utils/array-buffer-utils.js\";\n// GENERAL UTILITIES\n/**\n * Iterate over async iterator, without resetting iterator if end is not reached\n * - forEach intentionally does not reset iterator if exiting loop prematurely\n *   so that iteration can continue in a second loop\n * - It is recommended to use a standard for-await as last loop to ensure\n *   iterator gets properly reset\n *\n * TODO - optimize using sync iteration if argument is an Iterable?\n *\n * @param iterator\n * @param visitor\n */\nexport async function forEach(iterator, visitor) {\n    // eslint-disable-next-line\n    while (true) {\n        const { done, value } = await iterator.next();\n        if (done) {\n            iterator.return();\n            return;\n        }\n        const cancel = visitor(value);\n        if (cancel) {\n            return;\n        }\n    }\n}\n// Breaking big data into iterable chunks, concatenating iterable chunks into big data objects\n/**\n * Concatenates all data chunks yielded by an (async) iterator\n * This function can e.g. be used to enable atomic parsers to work on (async) iterator inputs\n */\nexport async function concatenateArrayBuffersAsync(asyncIterator) {\n    const arrayBuffers = [];\n    for await (const chunk of asyncIterator) {\n        arrayBuffers.push(chunk);\n    }\n    return concatenateArrayBuffers(...arrayBuffers);\n}\nexport async function concatenateStringsAsync(asyncIterator) {\n    const strings = [];\n    for await (const chunk of asyncIterator) {\n        strings.push(chunk);\n    }\n    return strings.join('');\n}\n","// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log } from \"../log-utils/log.js\";\n/**\n * Register application-imported modules\n * These modules are typically to big to bundle, or may have issues on some bundlers/environments\n */\nexport function registerJSModules(modules) {\n    globalThis.loaders ||= {};\n    globalThis.loaders.modules ||= {};\n    Object.assign(globalThis.loaders.modules, modules);\n}\n/**\n * Get a pre-registered application-imported module, warn if not present\n */\nexport function checkJSModule(name, caller) {\n    const module = globalThis.loaders?.modules?.[name];\n    if (!module) {\n        log.warn(`${caller}: ${name} library not installed`)();\n    }\n}\n/**\n * Get a pre-registered application-imported module, throw if not present\n */\nexport function getJSModule(name, caller) {\n    const module = globalThis.loaders?.modules?.[name];\n    if (!module) {\n        throw new Error(`${caller}: ${name} library not installed`);\n    }\n    return module;\n}\n/**\n * Get a pre-registered application-imported module, return null if not present\n */\nexport function getJSModuleOrNull(name) {\n    const module = globalThis.loaders?.modules?.[name];\n    return module || null;\n}\n","// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isBrowser } from \"../env-utils/globals.js\";\nconst NOT_IMPLEMENTED = new Error('Not implemented');\n/** This class is a facade that gets replaced with an actual NodeFile instance  */\nexport class NodeFileFacade {\n    handle;\n    size = 0;\n    bigsize = 0n;\n    url = '';\n    constructor(url, flags, mode) {\n        // Return the actual implementation instance\n        if (globalThis.loaders?.NodeFile) {\n            return new globalThis.loaders.NodeFile(url, flags, mode);\n        }\n        if (isBrowser) {\n            throw new Error('Can\\'t instantiate NodeFile in browser.');\n        }\n        throw new Error('Can\\'t instantiate NodeFile. Make sure to import @loaders.gl/polyfills first.');\n    }\n    /** Read data */\n    async read(start, length) {\n        throw NOT_IMPLEMENTED;\n    }\n    /** Write to file. The number of bytes written will be returned */\n    async write(arrayBuffer, offset, length) {\n        throw NOT_IMPLEMENTED;\n    }\n    /** Get information about file */\n    async stat() {\n        throw NOT_IMPLEMENTED;\n    }\n    /** Truncates the file descriptor. Only available on NodeFile. */\n    async truncate(length) {\n        throw NOT_IMPLEMENTED;\n    }\n    /** Append data to a file. Only available on NodeFile. */\n    async append(data) {\n        throw NOT_IMPLEMENTED;\n    }\n    /** Close the file */\n    async close() { }\n}\n","// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { resolvePath } from '@loaders.gl/loader-utils';\nimport { makeResponse } from \"../utils/response-utils.js\";\n// import {FetchError} from './fetch-error';\nexport function isNodePath(url) {\n    return !isRequestURL(url) && !isDataURL(url);\n}\nexport function isRequestURL(url) {\n    return url.startsWith('http:') || url.startsWith('https:');\n}\nexport function isDataURL(url) {\n    return url.startsWith('data:');\n}\n/**\n * fetch API compatible function\n * - Supports fetching from Node.js local file system paths\n * - Respects pathPrefix and file aliases\n */\nexport async function fetchFile(urlOrData, fetchOptions) {\n    if (typeof urlOrData === 'string') {\n        const url = resolvePath(urlOrData);\n        // Support fetching from local file system\n        if (isNodePath(url)) {\n            if (globalThis.loaders?.fetchNode) {\n                return globalThis.loaders?.fetchNode(url, fetchOptions);\n            }\n            // throw new Error(\n            //   'fetchFile: globalThis.loaders.fetchNode not defined. Install @loaders.gl/polyfills'\n            // );\n        }\n        // Call global fetch\n        return await fetch(url, fetchOptions);\n    }\n    // TODO - should we still call fetch on non-URL inputs?\n    return await makeResponse(urlOrData);\n}\n","// Purpose: include this in your module to avoid\n// dependencies on micro modules like 'global' and 'is-browser';\n/* eslint-disable no-restricted-globals */\nconst globals = {\n    self: typeof self !== 'undefined' && self,\n    window: typeof window !== 'undefined' && window,\n    global: typeof global !== 'undefined' && global,\n    document: typeof document !== 'undefined' && document\n};\nconst self_ = globals.self || globals.window || globals.global || {};\nconst window_ = globals.window || globals.self || globals.global || {};\nconst global_ = globals.global || globals.self || globals.window || {};\nconst document_ = globals.document || {};\nexport { self_ as self, window_ as window, global_ as global, document_ as document };\n/** true if running in a browser */\nexport const isBrowser = \n// @ts-ignore process does not exist on browser\nBoolean(typeof process !== 'object' || String(process) !== '[object process]' || process.browser);\n/** true if running in a worker thread */\nexport const isWorker = typeof importScripts === 'function';\n// Extract node major version\nconst matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\n/** Major Node version (as a number) */\nexport const nodeVersion = (matches && parseFloat(matches[1])) || 0;\n"],"names":["data","value","isBuffer","ArrayBuffer","isView","byteOffset","byteLength","buffer","slice","text","TextEncoder","encode","_toArrayBuffer","Error","async","makeResponse","resource","headers","contentLength","String","url","type","initialDataUrl","Blob","blobSlice","Promise","resolve","reader","FileReader","onload","event","target","result","readAsDataURL","binary","bytes","Uint8Array","i","fromCharCode","btoa","arrayBufferToBase64","getInitialDataUrl","response","Response","Object","defineProperty","checkResponse","ok","error","shortUrl","message","status","statusText","length","info","reason","contentType","get","bodyUsed","includes","json","getResponseError","QUERY_STRING_PATTERN","extractQueryString","matches","match","stripQueryString","replace","shortenUrlForDisplay","urlEnd","substr","compareArrayBuffers","arrayBuffer1","arrayBuffer2","array1","array2","concatenateArrayBuffers","sources","concatenateArrayBuffersFromArray","sourceArrays","map","source2","reduce","typedArray","offset","sourceArray","set","DATA_URL_PATTERN","MIME_TYPE_PATTERN","compareMIMETypes","mimeType1","mimeType2","toLowerCase","parseMIMEType","mimeString","exec","parseMIMETypeFromURL","getResourceUrl","name","getResourceMIMEType","contentTypeHeader","noQueryUrl","getResourceContentLength","size","FetchError","constructor","super","this","filename","slashIndex","lastIndexOf","dirname","join","parts","part","index","RegExp","pathPrefix","fileAliases","setPathPrefix","prefix","getPathPrefix","resolvePath","alias","startsWith","replacement","isBoolean","x","isFunction","isObject","isPureObject","isPromise","then","isIterable","Boolean","Symbol","iterator","isAsyncIterable","asyncIterator","isIterator","next","isResponse","arrayBuffer","isBlob","isReadableStream","ReadableStream","tee","cancel","getReader","isReadableDOMStream","read","pipe","readable","isReadableNodeStream","isWritableStream","abort","getWriter","isWritableDOMStream","end","write","writable","isWritableNodeStream","forEach","visitor","done","return","concatenateArrayBuffersAsync","arrayBuffers","chunk","push","registerJSModules","modules","globalThis","loaders","assign","NOT_IMPLEMENTED","NodeFileFacade","handle","bigsize","flags","mode","NodeFile","start","stat","truncate","append","close","fetchFile","urlOrData","fetchOptions","isRequestURL","isDataURL","isNodePath","fetchNode","fetch","globals","self","window","global","g","document","self_","window_","global_","document_","isBrowser","process","browser","isWorker","importScripts","version","parseFloat"],"ignoreList":[],"sourceRoot":""}